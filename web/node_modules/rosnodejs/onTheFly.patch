diff --git a/utils/IndentedWriter.js b/utils/IndentedWriter.js
new file mode 100644
index 0000000..244df72
--- /dev/null
+++ b/utils/IndentedWriter.js
@@ -0,0 +1,56 @@
+'use strict';
+
+class IndentedWriter {
+  constructor() {
+    this._str = '';
+    this._indentation = 0;
+  }
+
+  write() {
+    let formattedStr = util.format.apply(this,arguments);
+    if (this.isIndented()) {
+      for (let i = 0; i < this._indentation; ++i) {
+        this._str += '  ';
+      }
+    }
+    this._str += formattedStr;
+    return this.newline();
+  }
+
+  newline() {
+    this._str += '\n';
+    return this;
+  }
+
+  indent() {
+    ++this._indentation;
+    return this;
+  }
+
+  isIndented() {
+    return this._indentation > 0;
+  }
+
+  dedent() {
+    --this._indentation;
+    if (this._indentation < 0) {
+      this.resetIndent();
+    }
+    return this;
+  }
+
+  resetIndent() {
+    this._indentation = 0;
+    return this;
+  }
+
+  dividingLine() {
+    return this.write('//-----------------------------------------------------------');
+  }
+
+  get() {
+    return this._str;
+  }
+};
+
+module.exports = IndentedWriter;
diff --git a/utils/fields.js b/utils/fields.js
index 6a991b7..84ab37d 100644
--- a/utils/fields.js
+++ b/utils/fields.js
@@ -36,6 +36,27 @@ fields.getDefaultValue = function(type) {
   }
 };
 
+fields.isString = function(type) {
+  return type === 'string';
+}
+
+fields.isTime = function(type) {
+  return type === 'time' || type === 'duration';
+}
+
+fields.isBool = function(type) {
+  return type === 'bool';
+}
+
+fields.isFloat = function(type) {
+  return type === 'float32' || type === 'float64';
+}
+
+fields.isInteger = function(type) {
+  return (['byte', 'char', 'int8', 'uint8', 'int16', 'uint16',
+           'int32', 'uint32', 'int64', 'uint64'].indexOf('type') >= 0);
+}
+
 fields.isPrimitive = function(fieldType) {
   return (fields.primitiveTypes.indexOf(fieldType) >= 0);
 };
@@ -54,6 +75,54 @@ fields.getTypeOfArray = function(arrayType) {
                                  : false;
 }
 
+fields.getLengthOfArray = function(arrayType) {
+  var match = arrayType.match(/.*\[(\d*)\]$/);
+  if (match[1] === '') {
+    return null;
+  }
+  return parseInt(match[1]);
+}
+
+function parseType(msgType, field) {
+  if (!msgType) {
+    throw new Error(`Invalid empty type ${JSON.stringify(field)}`);
+  }
+  // else
+  if (fields.isArray(msgType)) {
+    field.isArray = true;
+    var constantLength = msgType.endsWith('[]');
+    var splits = msgType.split('[');
+    if (splits.length > 2) {
+      throw new Error(`Only support 1-dimensional array types: ${msgType}`);
+    }
+    field.baseType = splits[0];
+    if (constantLength) {
+      field.arrayLen = fields.getLengthOfArray(msgType);
+    }
+    else {
+      field.arrayLen = null;
+    }
+  }
+  else {
+    field.baseType= msgType;
+    field.isArray = false;
+    field.arrayLen = null;
+  }
+}
+
+function isHeader(type) {
+  return (['Header', 'std_msgs/Header', 'roslib/Header'].indexOf(type) >= 0);
+}
+
+fields.Field = function(name, type) {
+  this.name = name
+  this.type = type
+  parseType(type, this);
+  this.isHeader = isHeader(type);
+  this.isBuiltin = fields.isPrimitive(this.baseType);
+};
+
+
 fields.parsePrimitive = function(fieldType, fieldValue) {
   var parsedValue = fieldValue;
 
@@ -117,7 +186,7 @@ fields.parsePrimitive = function(fieldType, fieldValue) {
   return parsedValue;
 };
 
-fields.serializePrimitive = 
+fields.serializePrimitive =
   function(fieldType, fieldValue, buffer, bufferOffset) {
     if (fieldType === 'bool') {
       buffer.writeUInt8(fieldValue, bufferOffset);
@@ -316,4 +385,3 @@ function throwUnsupportedInt64Exception() {
   var error = new Error('int64 and uint64 are currently unsupported field types. See https://github.com/baalexander/rosnodejs/issues/2');
   throw error;
 }
-
diff --git a/utils/messages.js b/utils/messages.js
index 14baf9a..2ffdeb8 100644
--- a/utils/messages.js
+++ b/utils/messages.js
@@ -1,12 +1,50 @@
+'use strict';
 var fs = require('fs');
 var path = require('path');
+var util = require('util');
 var md5 = require('md5');
 var async = require('async');
 
 var packages   = require('./packages')
-  , fieldsUtil = require('./fields');
+  , fieldsUtil = require('./fields')
+  , IndentedWriter = require('./IndentedWriter.js');
+
+const Field = fieldsUtil.Field;
 
 var messages = exports;
+packages.findMessagePackages();
+console.log('done finding messages');
+var packageCache = packages.getPackageCache();
+
+Object.keys(packageCache).forEach((packageName) => {
+
+  let packageInfo = packageCache[packageName];
+  // console.log('package %s: %j', packageName, packageInfo);
+
+  packageInfo.forEach = (item, func) => {
+    let itemInfo = packageInfo[item];
+    Object.keys(itemInfo).forEach((item) => {
+      func(item, itemInfo[item]);
+    })
+  };
+
+  let fullName = function(name) {
+    return packageName + '/' + name;
+  }
+
+  packageInfo.forEach('messages', (message, file) => {
+    console.log('loading message %s from %s', message, file);
+    getMessageFromFile(fullName(message), file, ['msg']);
+  });
+  packageInfo.forEach('services', (message, file) => {
+    console.log('loading service %s from %s', message, file);
+    getMessageFromFile(fullName(message), file, ['srv', 'Request']);
+    getMessageFromFile(fullName(message), file, ['srv', 'Response']);
+  });
+  packageInfo.forEach('actions', (message, file) => {
+    console.log('skipping action %s from %s', message, file);
+  });
+});
 
 // ---------------------------------------------------------
 // exported functions
@@ -36,21 +74,21 @@ messages.getService = function(messageType, callback) {
 // Registry
 
 var registry = {};
-/* 
+/*
    registry looks like:
-  { 'packagename': 
+  { 'packagename':
     {
-      msg: { 
+      msg: {
         'String': classdef,
         'Pose': classdef,
         ...
       },
-      srv: { Request: 
+      srv: { Request:
              {
                'SetBool': classdef,
                ...
              },
-             Response: 
+             Response:
              {
                'SetBool': classdef,
                ...
@@ -64,8 +102,8 @@ var registry = {};
 /**
    @param messageType is the ROS message or service type, e.g.
    'std_msgs/String'
-   @param type is from the set 
-   [["msg"], ["srv","Request"], ["srv","Response"] 
+   @param type is from the set
+   [["msg"], ["srv","Request"], ["srv","Response"]
 */
 function getMessageFromRegistry(messageType, type) {
   var packageName = getPackageNameFromMessageType(messageType);
@@ -90,10 +128,10 @@ function getMessageFromRegistry(messageType, type) {
   }
 }
 
-/** 
+/**
     @param messageType is the ROS message or service type, e.g.
     'std_msgs/String'
-    @param message is the message class definition 
+    @param message is the message class definition
     @param type is from the set "msg", "srv"
     @param (optional) subtype \in { "Request", "Response" }
 */
@@ -115,8 +153,8 @@ function setMessageInRegistry(messageType, message, type, subtype) {
       registry[packageName][type][messageName] = {};
     }
 
-    var serviceType = subtype; // "Request" or "Response"
-    registry[packageName][type][messageName][serviceType] = message;    
+    var serviceType = type[1]; // "Request" or "Response"
+    registry[packageName][kind][messageName][serviceType] = message;
   }
 }
 
@@ -135,105 +173,50 @@ function getMessageFromPackage(messageType, type, callback) {
   });
 };
 
-function getMessageFromFile(messageType, filePath, type, callback) {
+function getMessageFromFile(messageType, filePath, type) {
   var packageName = getPackageNameFromMessageType(messageType)
   , messageName = getMessageNameFromMessageType(messageType);
-  
+
   var details = {
     messageType : messageType
     , messageName : messageName
     , packageName : packageName
   };
 
-  parseMessageFile(
-    filePath, details, type, function(error, details) {
-      if (error) {
-        callback(error);
-      } else {
-        if (type == "msg") {
-          message = buildMessageClass(details);
-          setMessageInRegistry(messageType, message, type);
-          callback(null, message);
-        } else if (type == "srv") {
-          request = buildMessageClass(details.request);
-          response = buildMessageClass(details.response);
-          setMessageInRegistry(messageType, request, type, "Request");
-          setMessageInRegistry(messageType, response, type, "Response");
-          callback(null, message);
-        } else {
-          console.log("unknown service", type);
-        }
-      }
-    });
+  parseMessageFile(filePath, details, type);
+  if (type[0] === 'msg') {
+    buildMessageClass(details);
+  }
 };
 
-function parseMessageFile(fileName, details, type, callback) {
+function parseMessageFile(fileName, details, type) {
   details = details || {};
-  fs.readFile(fileName, 'utf8', function(error, content) {
-    if (error) {
-      return callback(error);
-    }
-    else {
-      extractFields(
-        content, details, type, function(error, aggregate) {
-          if (error) {
-            callback(error);
-          } else {
-            if (type == "msg") {
-              details.constants = aggregate[0].constants;
-              details.fields    = aggregate[0].fields;
-              details.md5       = calculateMD5(details, "msg");
-              callback(null, details);
-            } else if (type == "srv") {
-              // services combine the two message types to compute the
-              // md5sum
-              var rtv = {
-                // we need to clone what's already there in details
-                // into the sub-objects
-                request: JSON.parse(JSON.stringify(details)),
-                response: JSON.parse(JSON.stringify(details))
-              };
-              rtv.request.constants = aggregate[0].constants;
-              rtv.request.fields = aggregate[0].fields;
-              rtv.response.constants = aggregate[1].constants;
-              rtv.response.fields = aggregate[1].fields;
-              rtv.request.md5 = rtv.response.md5 = calculateMD5(rtv, "srv");
-              callback(null, rtv);
-            } else {
-              console.log("parseMessageFile:", "Unknown type: ", type);
-              callback("unknown type", null);
-            }
-          }
-        });
-    }
-  })
+  let content = fs.readFileSync(fileName, 'utf8');
+  let info = extractFields(content, details, type);
+  details.constants = info.constants;
+  details.fields    = info.fields;
+  details.md5       = calculateMD5(details);
+  return details;
 };
 
 // -------------------------------
 // functions relating to handler class
 
-function calculateMD5(details, type) {
-
-  /* get the text for one part of the type definition to compute the
-     md5sum over */
-  function getMD5text(part) {
-    var message = '';
-    var constants = part.constants.map(function(field) {
-      return field.type + ' ' + field.name + '=' + field.value;
-    }).join('\n');
-    
-    var fields = part.fields.map(function(field) {
-      if (field.messageType) {
-        return field.messageType.md5 + ' ' + field.name;
-      }
-      else {
-        return field.type + ' ' + field.name;
-      }
-    }).join('\n');
-    
-    message += constants;
-    if (message.length > 0 && fields.length > 0) {
-      message += "\n";
+
+function calculateMD5(details) {
+  var message = '';
+
+  var constants = details.constants.map(function(field) {
+    return field.type + ' ' + field.name + '=' + field.value;
+  }).join('\n');
+
+  var fields = details.fields.map(function(field) {
+    if (!field.isBuiltin) {
+      // FIXME: load the message for this type and calculate its md5
+      return '';
+    }
+    else {
+      return field.type + ' ' + field.name;
     }
     message += fields;
     return message;
@@ -247,7 +230,7 @@ function calculateMD5(details, type) {
     text = getMD5text(details);
   } else if (type == "srv") {
     text = getMD5text(details.request);
-    text += getMD5text(details.response);   
+    text += getMD5text(details.response);
   } else {
     console.log("calculateMD5: Unknown type", type);
     return null;
@@ -256,14 +239,13 @@ function calculateMD5(details, type) {
   return md5(text);
 }
 
-function extractFields(content, details, type, callback) {
-  function parsePart(lines, callback) {
-    var constants = []
+function extractFields(content, details, type) {
+  var constants = []
     , fields    = []
     ;
 
-    var parseLine = function(line, callback) {
-      line = line.trim();
+  var parseLine = function(line) {
+    line = line.trim();
 
       var lineEqualIndex   = line.indexOf('=')
       , lineCommentIndex = line.indexOf('#')
@@ -275,79 +257,29 @@ function extractFields(content, details, type, callback) {
         line = line.replace(/#.*/, '');
       }
 
-      if (line === '') {
-        callback();
-      }
-      else {
-        var firstSpace = line.indexOf(' ')
+    if (line !== '') {
+      var firstSpace = line.indexOf(' ')
         , fieldType  = line.substring(0, firstSpace)
         , field      = line.substring(firstSpace + 1)
         , equalIndex = field.indexOf('=')
         , fieldName  = field.trim()
         ;
 
-        if (equalIndex !== -1) {
-          fieldName = field.substring(0, equalIndex).trim();
-          var constant = field.substring(equalIndex + 1, field.length).trim();
-          var parsedConstant = fieldsUtil.parsePrimitive(fieldType, constant);
-
-          constants.push({
-            name        : fieldName
-            , type        : fieldType
-            , value       : parsedConstant
-            , index       : fields.length
-            , messageType : null
-          });
-          callback();
-        }
-        else {
-          if (fieldsUtil.isPrimitive(fieldType)) {
-            fields.push({
-              name        : fieldName.trim()
-              , type        : fieldType
-              , index       : fields.length
-              , messageType : null
-            });
-            callback();
-          }
-          else if (fieldsUtil.isArray(fieldType)) {
-            var arrayType = fieldsUtil.getTypeOfArray(fieldType);
-            if (fieldsUtil.isMessage(arrayType)) {
-              fieldType = normalizeMessageType(fieldType, details.packageName);
-              arrayType = normalizeMessageType(arrayType, details.packageName);
-              messages.getMessage(arrayType, function(error, messageType) {
-                fields.push({
-                  name        : fieldName.trim()
-                  , type        : fieldType
-                  , index       : fields.length
-                  , messageType : messageType
-                });
-                callback();
-              });
-            }
-            else {
-              fields.push({
-                name        : fieldName.trim()
-                , type        : fieldType
-                , index       : fields.length
-                , messageType : null
-              });
-              callback();
-            }
-          }
-          else if (fieldsUtil.isMessage(fieldType)) {
-            fieldType = normalizeMessageType(fieldType, details.packageName);
-            messages.getMessage(fieldType, function(error, messageType) {
-              fields.push({
-                name        : fieldName.trim()
-                , type        : fieldType
-                , index       : fields.length
-                , messageType : messageType
-              });
-              callback();
-            });
-          }
-        }
+      if (equalIndex !== -1) {
+        fieldName = field.substring(0, equalIndex).trim();
+        var constant = field.substring(equalIndex + 1, field.length).trim();
+        var parsedConstant = fieldsUtil.parsePrimitive(fieldType, constant);
+
+        constants.push({
+          name        : fieldName
+        , type        : fieldType
+        , value       : parsedConstant
+        , index       : fields.length
+        , messageType : null
+        });
+      }
+      else {
+        fields.push(new Field(fieldName.trim(), fieldType));
       }
     }
 
@@ -360,27 +292,24 @@ function extractFields(content, details, type, callback) {
       }
     });
   }
-    
 
 
-
-  var lines = content.split('\n');
-
-  // break into parts:
-  var parts = lines.reduce(function(memo, line) {
-    if (line == "---") {
-      // new part starts
-      memo.push([]);
-    } else if (line != "") {
-      memo[memo.length - 1].push(line);
+  var lines = content.split('\n').map((line) => line.trim());
+  if (type[0] != "msg") {
+    var divider = lines.indexOf("---");
+    if (type[1] == "Request") {
+      lines = lines.slice(0, divider);
+    } else {
+      // response
+      lines = lines.slice(divider+1);
     }
-    return memo;
-  }, [[]]);
- 
-  async.map(parts, parsePart, function(err, aggregate) {
-    callback(err, aggregate);
-  });
+  }
 
+  lines.forEach(parseLine);
+  return {
+    constants: constants,
+    fields: fields
+  };
 };
 
 function camelCase(underscoreWord, lowerCaseFirstLetter) {
@@ -395,43 +324,308 @@ function camelCase(underscoreWord, lowerCaseFirstLetter) {
   return camelCaseWord;
 }
 
-function buildValidator (details) {
+function getMessageDependencies(details) {
+  let deps = [];
+  details.fields.forEach((field) => {
+    if (!field.isBuiltin) {
+      deps.push(field);
+    }
+  });
+  return deps;
+}
 
-  function validator (candidate, strict) {
-    return Object.keys(candidate).every(function(property) {
-      var valid = true;
-      var exists = false;
+function writeHeader(w, details) {
+  w.dividingLine();
+  w.write('// Auto-generated from package %s.', details.packageName);
+  w.write('// !! Do not edit !!');
+  w.dividingLine();
+  w.newline();
+}
 
-      details.constants.forEach(function(field) {
-        if (field.name === property) {
-          exists = true;
-        }
-      });
-      if (!exists) {
-        details.fields.forEach(function(field) {
-          if (field.name === property) {
-            exists = true;
-          }
-        });
+function writeRequires(w, details, isSrv) {
+  w.write('"use strict";');
+  w.newline();
+  w.write('const _ros_msg_utils = require(\'ros_msg_utils\');');
+  w.write('const _serializer = _ros_msg_utils.Serialize;');
+  w.write('const _deserializer = _ros_msg_utils.Deserialize;');
+  w.write('const _finder = _ros_msg_utils.Find;');
+  let deps = getMessageDependencies(details);
+  const packageName = details.packageName;
+  deps.forEach((dep) => {
+    let depPack = getPackageNameFromMessageType(dep.type);
+    if (depPack === packageName) {
+      if (isSrv) {
+        w.write('const %s = require(\'../msg/%s.js\');', dep.name, dep.name);
+      } else {
+        w.write('const %s = require(\'./%s.js\');', dep.name, dep.name);
       }
+    }
+    else {
+      w.write('const %s = _finder(\'%s\');', depPack, depPack);
+    }
+  });
 
-      if (strict) {
-        return exists;
-      }
-      else {
-        return valid;
+  w.newline()
+  w.dividingLine();
+  w.newline()
+}
+
+function getDefaultValue(field, packageName) {
+  if (field.isArray) {
+    if (!field.arrayLen) {
+      return '[]';
+    }
+    else {
+      let fieldCopy = Object.assign({}, field);
+      fieldCopy.isArray = false;
+      let fieldDefault = getDefaultValue(fieldCopy, packageName);
+      return util.format('new Array(%s).fill(%s)', field.arrayLen, fieldDefault);
+    }
+  }
+  else if (field.isBuiltin) {
+    if (fieldsUtil.isString(field.type)) {
+      return '\'\'';
+    } else if (fieldsUtil.isTime(field.type)) {
+      return '{secs: 0, nsecs: 0}';
+    } else if (fieldsUtil.isBool(field.type)) {
+      return 'false';
+    } else if (fieldsUtil.isFloat(field.type)) {
+      return '0.0'
+    }
+    // else is int
+    return '0';
+  }
+  // else
+  let fieldInfo = field.type.split('/')
+  if (fieldInfo[0] === packageName) {
+    return util.format('new %s()', fieldInfo[1]);
+  }
+  // else
+  return util.format('new %s.msg.%s()',fieldInfo[0], fieldInfo[1]);
+}
+
+function writeMsgConstructorField(w, details, field) {
+    w.write('if (initObj.hasOwnProperty(\'%s\')) {', field.name).indent();
+    w.write('this.%s = initObj.%s;', field.name, field.name).dedent();
+    w.write('}')
+    w.write('else {').indent();
+    w.write('this.%s = %s;', field.name, getDefaultValue(field, details.packageName)).dedent();
+    w.write('}');
+    w.newline();
+}
+
+function writeClass(w, details) {
+  w.write('class %s {', details.messageName);
+  w.indent();
+  w.write('constructor(initObj) {');
+  w.indent();
+  details.fields.forEach((field) => {
+    writeMsgConstructorField(w, details, field);
+  });
+  w.dedent().write('}').newline();
+}
+
+function writeSerializeLength(w, name) {
+  w.write(`// Serialize the length for message field [${name}]`)
+  .write(`bufferOffset = _serializer.uint32(obj.${name}.length, buffer, bufferOffset);`);
+}
+
+function writeSerializeLengthCheck(w, field) {
+  w.write(`// Check that the constant length array field [${field.name}] has the right length`)
+  .write(`if (obj.${field.name}.length !== ${field.arrayLen}) {`)
+  .indent()
+  .write(`throw new Error(\'Unable to serialize array field ${field.name} - length must be ${field.arrayLen}\')`)
+  .dedent()
+  .write('}');
+}
+
+function writeSerializeBuiltinField(w, f) {
+  if (f.isArray) {
+    if (f.type === 'uint8') {
+      w.write(`buffer.write(obj.${f.name});`);
+      w.write(`bufferOffset += obj.${f.name}.length;`);
+    }
+    else {
+      w.write(`obj.${f.name}.forEach((val) => {`)
+      .indent()
+      .write(`bufferOffset = _serializer.${f.type}(val, buffer, bufferOffset);`)
+      .dedent()
+      .write('});');
+    }
+  }
+  else {
+    w.write(`bufferOffset = _serializer.${f.type}(obj.${f.name}, buffer, bufferOffset);`);
+  }
+}
+
+function writeSerializeMessageField(w, f, thisPackage) {
+  let fieldPackage = getPackageNameFromMessageType(f.type);
+  let msgName = getMessageNameFromMessageType(f.type);
+  let samePackage = (fieldPackage === thisPackage);
+  if (f.isArray) {
+    w.write(`obj.${f.name}.forEach((val) => {`)
+    .indent();
+    if (samePackage) {
+      w.write(`bufferOffset = ${msgName}.serialize(val, buffer, bufferOffset);`);
+    }
+    else {
+      w.write(`bufferOffset = ${fieldPackage}.msg.${msgName}.serialize(val, buffer, bufferOffset);`);
+    }
+    w.dedent()
+    .write('});');
+  }
+  else {
+    if (samePackage) {
+      w.write(`bufferOffset = ${msgName}.serialize(obj.${f.name}, buffer, bufferOffset);`);
+    }
+    else {
+      w.write(`bufferOffset = ${fieldPackage}.msg.${msgName}.serialize(obj.${f.name}, buffer, bufferOffset);`);
+    }
+  }
+}
+
+function writeSerializeField(w, field, packageName) {
+  if (field.isArray) {
+    if (!field.arrayLen) {
+      writeSerializeLength(w, field.name);
+    }
+    else {
+      writeSerializeLengthCheck(w, field);
+    }
+    w.newline();
+  }
+  w.write('// Serialize message field [%s]', field.name).newline();
+  if (field.isBuiltin) {
+    writeSerializeBuiltinField(w, field);
+  }
+  else {
+    writeSerializeMessageField(w, field, packageName);
+  }
+  w.newline();
+}
+
+function writeSerialize(w, details) {
+  w.write('static serialize(obj, buffer, bufferOffset) {')
+  .indent()
+  .write('// Serializes a message object of type %s', details.messageName);
+  details.fields.forEach((field) => {
+    writeSerializeField(w, field, details.packageName);
+  });
+  w.write('return bufferOffset;')
+  .dedent()
+  .write('}')
+  .newline();
+}
+
+function writeDeserializeLength(w, name) {
+  w.write(`// Deserialize array length for message field [${name}]`);
+  w.write('len = _deserializer.uint32(buffer, bufferOffset);')
+}
+
+function writeDeserializeMessageField(w, field, thisPackage) {
+  const fieldPackage = getPackageNameFromMessageType(field.baseType);
+  const msgName = getMessageNameFromMessageType(field.baseType);
+  const samePackage = (fieldPackage === thisPackage);
+  if (field.isArray) {
+    // only create a new array if it has a non-constant length
+    if (!field.arrayLen) {
+      w.write(`data.${field.name} = new Array(len);`);
+    }
+    w.write('for (let i = 0; i < len; ++i) {')
+    .indent();
+    if (samePackage) {
+      w.write(`data.${field.name}[i] = ${msgName}.deserialize(buffer, bufferOffset);`);
+    }
+    else {
+      w.write(`data.${field.name}[i] = ${fieldPackage}.msg.${msgName}.deserialize(buffer, bufferOffset);`);
+    }
+    w.write('}');
+  }
+  else {
+    if (samePackage) {
+      w.write(`data.${field.name} = ${msgName}.deserialize(buffer, bufferOffset);`);
+    }
+    else {
+      w.write(`data.${field.name} = ${fieldPackage}.msg.${msgName}.deserialize(buffer, bufferOffset);`);
+    }
+  }
+}
+
+function writeDeserializeBuiltinField(w, field) {
+  if (field.isArray) {
+    if (field.baseType === 'uint8') {
+      w.write(`data.${field.name} = buffer.slice(0, len);`);
+      w.write('bufferOffset[0] += len;');
+    }
+    else {
+      // only create a new array if it has a non-constant length
+      if (!field.arrayLen) {
+        w.write(`data.${field.name} = new Array(len);`);
       }
-    });
+      w.write('for (let i = 0; i < len; ++i) {')
+      .indent()
+      .write(`data.${field.name}[i] = _deserializer.${field.baseType}(buffer, bufferOffset);`)
+      .dedent()
+      .write('}');
+    }
+  }
+  else {
+    w.write(`data.${field.name} = _deserializer.${field.baseType}(bufferInfo, bufferOffset);`);
   }
+}
 
-  validator.name = 'validate' + camelCase(details.messageName);
-  return validator;
+function writeDeserializeField(w, field, packageName) {
+  if (field.isArray) {
+    if (!field.arrayLen) {
+      writeDeserializeLength(w, field.name);
+    }
+    else {
+      w.write(`len = ${field.arrayLen};`);
+    }
+  }
+  w.write(`// Deserialize message field [${field.name}]`).newline();
+  if (field.isBuiltin) {
+    writeDeserializeBuiltinField(w, field);
+  }
+  else {
+    writeDeserializeMessageField(w, field, packageName);
+  }
+  w.newline()
+}
+
+function writeDeserialize(w, details) {
+  w.write('static deserialize(buffer, bufferOffset) {')
+  .indent()
+  .write('// Deserializes a message object of type %s', details.messageName);
+  details.fields.forEach((field) => {
+    writeDeserializeField(w, field, details.packageName);
+  });
+  w.write('return data;')
+  .dedent()
+  .write('}')
+  .newline();
 }
 
+
 /** Construct the class definition for the given message type. The
  * resulting class holds the data and has the methods required for
  * use with ROS, incl. serialization, deserialization, and md5sum. */
 function buildMessageClass(details) {
+  const fileWriter = new IndentedWriter();
+  writeHeader(fileWriter, details);
+  writeRequires(fileWriter, details, false);
+  writeClass(fileWriter, details);
+  writeSerialize(fileWriter, details);
+  writeDeserialize(fileWriter, details);
+  writeGetMessageSize(s, spec, search_path);
+  writeGetMessageFixedSize(s, spec, search_path)
+  write_ros_datatype(s, spec)
+  write_md5sum(s, context, spec)
+  write_message_definition(s, context, spec)
+  fileWriter.write('};').newline()
+  write_constants(s, spec)
+  console.log('CLASS SO FAR:\n' + fileWriter.get());
+
   function Message(values) {
     if (!(this instanceof Message)) {
       return new Message(values);
@@ -446,28 +640,28 @@ function buildMessageClass(details) {
     }
 
     if (details.fields) {
-      details.fields.forEach(function(field) {       
+      details.fields.forEach(function(field) {
         if (field.messageType) {
           // sub-message class
-          that[field.name] = 
+          that[field.name] =
             new (field.messageType)(values ? values[field.name] : undefined);
         } else {
           // simple value
-          that[field.name] = values ? values[field.name] : 
+          that[field.name] = values ? values[field.name] :
             (field.value || fieldsUtil.getDefaultValue(field.type));
         }
       });
     }
   };
 
-  Message.messageType = Message.prototype.messageType = details.messageType;
+  Message.messageType = Message.prototype.messageType = details.type;
   Message.packageName = Message.prototype.packageName = details.packageName;
   Message.messageName = Message.prototype.messageName = details.messageName;
   Message.md5         = Message.prototype.md5         = details.md5;
   Message.md5sum      = Message.prototype.md5sum      = function() {
     return this.md5;
   };
-  Message.Constants = Message.constants   
+  Message.Constants = Message.constants
     = Message.prototype.constants   = details.constants;
   Message.fields      = Message.prototype.fields      = details.fields;
   Message.serialize   = Message.prototype.serialize   =
@@ -478,7 +672,6 @@ function buildMessageClass(details) {
     var obj = deserializeMessage(buffer, Message);
     return obj;
   }
-  Message.prototype.validate    = buildValidator(details);
 
   return Message;
 }
diff --git a/utils/packages.js b/utils/packages.js
index 45c0383..d7f84a3 100644
--- a/utils/packages.js
+++ b/utils/packages.js
@@ -1,67 +1,82 @@
+'use strict';
 var fs          = require('fs')
   , path        = require('path')
-  , walker      = require('walker');
+  , walker      = require('./walker');
 
+let packageCache = {};
 
-function walk(directory, symlinks) {
-  var noSubDirs = [];
+function packageWalk(directory, symlinks, findMessages) {
+  var noSubDirs = new Set();
   var stopped = false;
   symlinks = symlinks || [];
 
-  return walker(directory)
-    .filterDir(function(dir, stat) {
-      // Exclude any subdirectory to an excluded directory
-      return !noSubDirs.some(function(subdir) {
-        return !subdir.indexOf(dir);
-      }) || !stopped;
-    })
-    .on('file', function(file, stat) {
-      var shortname = path.basename(file);
-      var dir = path.dirname(file);
-
-      if (shortname === 'manifest.xml' || shortname === 'package.xml') {
-        this.emit('package', path.basename(dir), dir);
-        // There is no subpackages, so ignore anything under this directory
-        noSubDirs.concat(dir);
+  let dirWalk = walker(directory)
+  .filterDir(function(dir, stat) {
+    // Exclude any subdirectory to an excluded directory
+    return !noSubDirs.has(dir) || !stopped;
+  })
+  .on('file', function(file, stat) {
+    var shortname = path.basename(file);
+    var dir = path.dirname(file);
+    var extension = path.extname(file);
+
+    if (shortname === 'manifest.xml' || shortname === 'package.xml') {
+      //console.log('found package %s!', file);
+      dirWalk.emit('package', path.basename(dir), dir);
+      // There is no subpackages, so ignore anything under this directory
+      noSubDirs.add(dir);
+    }
+    else if (findMessages) {
+      var name = path.basename(file, extension);
+      if (extension === '.msg') {
+        // console.log('Found message %s: %s', name, file);
+        dirWalk.emit('message', name, file);
       }
-      else if(shortname === 'rospack_nosubdirs') {
-        // Explicitly asked to not go into subdirectories
-        noSubDirs.concat(dir);
+      else if (extension === '.srv') {
+        // console.log('Found service %s: %s', name, file);
+        dirWalk.emit('service', name, file);
       }
-    })
-    .on('symlink', function(symlink, stat) {
-      var walker = this;
-      fs.readlink(symlink, function(error, link) {
-        if (error) {
-          return;
-        }
+      else if (extension === '.action') {
+        // console.log('Found action %s: %s', name, file);
+        dirWalk.emit('action', name, file);
+      }
+    }
+    else if(shortname === 'rospack_nosubdirs') {
+      // Explicitly asked to not go into subdirectories
+      noSubDirs.add(dir);
+    }
+  })
+  .on('symlink', function(symlink, stat) {
+    var walker = this;
+    try {
+      let link = fs.readlinkSync(symlink);
+      var destination = path.resolve(path.dirname(symlink), link);
 
-        var destination = path.resolve(path.dirname(symlink), link);
+      // Stores symlinks to avoid circular references
+      if (~symlinks.indexOf(destination)) {
+        return;
+      }
+      else {
+        symlinks.concat(destination);
+      }
 
-        // Stores symlinks to avoid circular references
-        if (~symlinks.indexOf(destination)) {
-          return;
-        }
-        else {
-          symlinks.concat(destination);
-        }
+      let stat = fs.statSync(destination);
+      if (stat.isDirectory()) {
+        dirWalk.emit('dir', destination, stat);
+        return dirWalk.go(destination);
+      }
+    }
+    catch (err) {
+      return
+    }
+  })
+  .on('end', function() {
+    stopped = true;
+    // Quit emitting
+    dirWalk.emit = function(){};
+  });
 
-        fs.stat(destination, function(error, stat) {
-          if (error) {
-            return;
-          }
-          else if (stat.isDirectory()) {
-            walker.emit('dir', destination, stat);
-            return walker.go(destination);
-          }
-        });
-      });
-    })
-    .on('end', function() {
-      stopped = true;
-      // Quit emitting
-      this.emit = function(){};
-    });
+  return dirWalk;
 }
 
 function findPackageInDirectory(directory, packageName, callback) {
@@ -76,7 +91,7 @@ function findPackageInDirectory(directory, packageName, callback) {
     })
     .on('end', function() {
       if (!found) {
-        var error = 
+        var error =
           new Error('ENOTFOUND - Package ' + packageName + ' not found');
         error.name = 'PackageNotFoundError';
         callback(error);
@@ -84,9 +99,42 @@ function findPackageInDirectory(directory, packageName, callback) {
     });
 }
 
+function findPackagesInDirectory(directory) {
+  let dirWalk = packageWalk(directory)
+  .on('package', (packageName, dir) => {
+    if (!packageCache.hasOwnProperty(packageName)) {
+      //console.log('Found package %s at %s', packageName, dir);
+      let packageEntry = {
+        directory: dir,
+        messages: {},
+        services: {},
+        actions: {}
+      };
+      let msgWalk = packageWalk(dir, null, true)
+      .on('message', (name, file) => {
+        packageEntry.messages[name] = file;
+      })
+      .on('service', (name, file) => {
+        packageEntry.services[name] = file;
+      })
+      .on('action', (name, file) => {
+        packageEntry.actions[name] = file;
+      })
+      .go();
+
+      if (Object.keys(packageEntry.messages).length > 0 ||
+          Object.keys(packageEntry.services).length > 0 ||
+          Object.keys(packageEntry.actions).length > 0) {
+        packageCache[packageName] = packageEntry;
+      }
+    }
+  })
+  .go();
+}
+
 function findPackageInDirectoryChain(directories, packageName, callback) {
   if (directories.length < 1) {
-    var error = 
+    var error =
       new Error('ENOTFOUND - Package ' + packageName + ' not found');
     error.name = 'PackageNotFoundError';
     callback(error);
@@ -97,7 +145,7 @@ function findPackageInDirectoryChain(directories, packageName, callback) {
         if (error) {
           if (error.name === 'PackageNotFoundError') {
             // Recursive call, try in next directory
-            return findPackageInDirectoryChain(directories, 
+            return findPackageInDirectoryChain(directories,
                                                packageName, callback);
           }
           else {
@@ -111,6 +159,13 @@ function findPackageInDirectoryChain(directories, packageName, callback) {
   }
 }
 
+function findPackagesInDirectoryChain(directories) {
+  directories.forEach((directory) => {
+    //console.log('look for packages in %s', directory);
+    findPackagesInDirectory(directory);
+  });
+}
+
 // ---------------------------------------------------------
 
 // Implements the same crawling algorithm as rospack find
@@ -124,3 +179,15 @@ exports.findPackage = function(packageName, callback) {
   return findPackageInDirectoryChain(directories, packageName, callback);
 }
 
+exports.findMessagePackages = function() {
+  var rosRoot = process.env.ROS_ROOT;
+  var packagePath = process.env.ROS_PACKAGE_PATH
+  var rosPackagePaths = packagePath.split(':')
+  var directories = [rosRoot].concat(rosPackagePaths);
+  findPackagesInDirectoryChain(directories);
+  //console.log('%j', packageCache);
+}
+
+exports.getPackageCache = function(pack) {
+  return Object.assign({}, packageCache);
+}
diff --git a/utils/walker.js b/utils/walker.js
new file mode 100644
index 0000000..daa435f
--- /dev/null
+++ b/utils/walker.js
@@ -0,0 +1,121 @@
+'use strict';
+module.exports = Walker
+
+var path = require('path')
+  , fs = require('fs')
+  , util = require('util')
+  , EventEmitter = require('events').EventEmitter
+  , makeError = require('makeerror')
+
+/**
+ * FIXME: this a a copy of walker in node_modules that is altered to be synchronous
+ * To walk a directory. It's complicated (but it's async, so it must be fast).
+ *
+ * @param root {String} the directory to start with
+ */
+function Walker(root) {
+  if (!(this instanceof Walker)) return new Walker(root)
+  EventEmitter.call(this)
+  this._pending = 0
+  this._filterDir = function() { return true }
+  if (!root) {
+    throw new Error('Unable to construct walker without root');
+  }
+  this._rootDir = root;
+}
+util.inherits(Walker, EventEmitter)
+
+/**
+ * Errors of this type are thrown when the type of a file could not be
+ * determined.
+ */
+var UnknownFileTypeError = Walker.UnknownFileTypeError = makeError(
+  'UnknownFileTypeError',
+  'The type of this file could not be determined.'
+)
+
+/**
+ * Setup a function to filter out directory entries.
+ *
+ * @param fn {Function} a function that will be given a directory name, which
+ * if returns true will include the directory and it's children
+ */
+Walker.prototype.filterDir = function(fn) {
+  this._filterDir = fn
+  return this
+}
+
+/**
+ * Process a file or directory.
+ */
+Walker.prototype.go = function(entry) {
+  if (entry === undefined) {
+    return this.go(this._rootDir);
+  }
+
+  var that = this
+  this._pending++
+
+  try {
+    let stat = fs.lstatSync(entry);
+    if (stat.isDirectory()) {
+      if (!that._filterDir(entry, stat)) {
+        that.doneOne()
+      } else {
+        try {
+          let files = fs.readdirSync(entry);
+          that.emit('entry', entry, stat)
+          that.emit('dir', entry, stat)
+          files.forEach(function(part) {
+            that.go(path.join(entry, part))
+          })
+          that.doneOne()
+        }
+        catch (err) {
+          that.emit('error', err, entry, stat)
+          that.doneOne()
+          return
+        }
+      }
+    } else if (stat.isSymbolicLink()) {
+      that.emit('entry', entry, stat)
+      that.emit('symlink', entry, stat)
+      that.doneOne()
+    } else if (stat.isBlockDevice()) {
+      that.emit('entry', entry, stat)
+      that.emit('blockDevice', entry, stat)
+      that.doneOne()
+    } else if (stat.isCharacterDevice()) {
+      that.emit('entry', entry, stat)
+      that.emit('characterDevice', entry, stat)
+      that.doneOne()
+    } else if (stat.isFIFO()) {
+      that.emit('entry', entry, stat)
+      that.emit('fifo', entry, stat)
+      that.doneOne()
+    } else if (stat.isSocket()) {
+      that.emit('entry', entry, stat)
+      that.emit('socket', entry, stat)
+      that.doneOne()
+    } else if (stat.isFile()) {
+      //console.log('found file ' + entry);
+      that.emit('entry', entry, stat)
+      that.emit('file', entry, stat)
+      that.doneOne()
+    } else {
+      that.emit('error', UnknownFileTypeError(), entry, stat)
+      that.doneOne()
+    }
+  }
+  catch (err) {
+    that.emit('error', err, entry)
+    that.doneOne()
+    return
+  }
+  return this
+}
+
+Walker.prototype.doneOne = function() {
+  if (--this._pending === 0) this.emit('end')
+  return this
+}
